/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rast_tri.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: babonnet <babonnet@42angouleme.fr>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/27 15:29:06 by babonnet          #+#    #+#             */
/*   Updated: 2024/06/02 21:02:01 by babonnet         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "mlx_data.h"
#include "print_int.h"
#include <stdio.h>
#include <stdint.h>
#include <immintrin.h>
#include <math.h>
#include <mlx.h>  // Ensure the correct path for mlx.h based on your project setup
#include <string.h>
#include <strings.h>

#define NR_PLANES 3
#define PIPE_MAX_COLOR_BUFS 8
#define BLOCK_SIZE 4

#define RIGHT_MASK_TAB_16 { \
    0xFFFFFFFF,             \
    0x0000FFFF,             \
    0x000000FF,             \
    0x0000000F              \
}

#define BOTTOM_MASK_TAB_16 { \
    0xFFFFFFFF,             \
    0xFFFF0000,             \
    0xFF000000,             \
    0x0F000000              \
}

struct u_rect {
    int x0, y0;
    int x1, y1;
};

struct lp_rast_shader_inputs {
    unsigned frontfacing : 1;
    unsigned disable : 1;
    unsigned is_blit : 1;
    unsigned viewport_index : 4;
    unsigned layer : 11;
    unsigned view_index : 14;
    unsigned stride;
    unsigned pad[2];
};

struct lp_rast_plane {
    int64_t c;
    int32_t dcdx;
    int32_t dcdy;
    uint32_t eo;
    uint32_t pad;
};

struct lp_rasterizer_task {
    const struct cmd_bin *bin;
    const struct lp_rast_state *state;
    struct lp_scene *scene;
    unsigned x, y;
    unsigned width, height;
    uint8_t *color_tiles[PIPE_MAX_COLOR_BUFS];
    uint8_t *depth_tile;
    struct lp_rasterizer *rast;
    unsigned thread_index;
    unsigned occlude;
};

struct lp_rast_triangle {
    struct lp_rast_shader_inputs inputs;
};

union lp_rast_cmd_arg {
    const struct lp_rast_shader_inputs *shade_tile;
    struct {
        const struct lp_rast_triangle *tri;
        unsigned plane_mask;
    } position;
    const struct lp_rast_rectangle *rectangle;
    const struct lp_rast_state *set_state;
    const struct lp_rast_clear_rb *clear_rb;
    struct {
        uint64_t value;
        uint64_t mask;
    } clear_zstencil;
    struct lp_fence *fence;
    struct llvmpipe_query *query_obj;
};

static inline struct lp_rast_plane *GET_PLANES(const struct lp_rast_triangle *tri) {
    const uint8_t *p = (const uint8_t *)(&tri->inputs + 1);
    return (struct lp_rast_plane *)(p + 3 * tri->inputs.stride);
}

static inline unsigned sign_bits4(const __m128i *cstep, int cdiff) {
    __m128i cio4 = _mm_set1_epi32(cdiff);
    __m128i cstep0 = _mm_add_epi32(cstep[0], cio4);
    __m128i cstep1 = _mm_add_epi32(cstep[1], cio4);
    __m128i cstep2 = _mm_add_epi32(cstep[2], cio4);
    __m128i cstep3 = _mm_add_epi32(cstep[3], cio4);
    __m128i cstep01 = _mm_packs_epi32(cstep0, cstep1);
    __m128i cstep23 = _mm_packs_epi32(cstep2, cstep3);
    __m128i result = _mm_packs_epi16(cstep01, cstep23);
    return _mm_movemask_epi8(result);
}

void custom_shade_quads_mask(struct lp_rasterizer_task *task, const struct lp_rast_shader_inputs *inputs, int px, int py, unsigned mask, int zbuffer[HEIGHT][WIDTH], unsigned int color, t_mlx *mlx) {
    for (int iy = 0; iy < 4; iy++) {
        for (int ix = 0; ix < 4; ix++) {
            if (mask & (1 << (iy * 4 + ix))) {
                int x = px + ix;
                int y = py + iy;
                if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
                    if (inputs->layer < zbuffer[y][x]) {
                        zbuffer[y][x] = inputs->layer;
                        mlx_pixel_put(mlx->connection, mlx->window, x, y, color);
                    }
                }
            }
        }
    }
}

void TRI_16(struct lp_rasterizer_task *task, const union lp_rast_cmd_arg arg, int zbuffer[HEIGHT][WIDTH], unsigned int color, t_mlx *mlx) {
    const struct lp_rast_triangle *tri = arg.position.tri;
    const struct lp_rast_plane *plane = GET_PLANES(tri);
    unsigned mask = arg.position.plane_mask;
    __m128i cstep4[NR_PLANES][4];
    int x = (mask & 0xff);
    int y = (mask >> 8);
    unsigned outmask = 0;
    static const uint32_t right_mask_tab[] = RIGHT_MASK_TAB_16;
    static const uint32_t bottom_mask_tab[] = BOTTOM_MASK_TAB_16;

    if (x + 12 >= 64) {
        int i = ((x + 12) - 64) / 4;
        outmask |= right_mask_tab[i];
    }

    if (y + 12 >= 64) {
        int i = ((y + 12) - 64) / 4;
        outmask |= bottom_mask_tab[i];
    }

    x += task->x;
    y += task->y;

    for (unsigned j = 0; j < NR_PLANES; j++) {
        const int dcdx = -plane[j].dcdx * 4;
        const int dcdy = plane[j].dcdy * 4;
        __m128i xdcdy = _mm_set1_epi32(dcdy);

        cstep4[j][0] = _mm_setr_epi32(0, dcdx, dcdx * 2, dcdx * 3);
        cstep4[j][1] = _mm_add_epi32(cstep4[j][0], xdcdy);
        cstep4[j][2] = _mm_add_epi32(cstep4[j][1], xdcdy);
        cstep4[j][3] = _mm_add_epi32(cstep4[j][2], xdcdy);

        const int c = plane[j].c + plane[j].dcdy * y - plane[j].dcdx * x;
        const int cox = plane[j].eo * 4;

        outmask |= sign_bits4(cstep4[j], c + cox);
    }

    if (outmask == 0xffff)
        return;

    unsigned partial_mask = 0xffff & ~outmask;

    while (partial_mask) {
        int i = ffs(partial_mask) - 1;
        int ix = (i & 3) * 4;
        int iy = (i >> 2) * 4;
        int px = x + ix;
        int py = y + iy;
        unsigned mask = 0xffff;

        partial_mask &= ~(1 << i);

        for (unsigned j = 0; j < NR_PLANES; j++) {
            const int cx = (plane[j].c - 1
                            - plane[j].dcdx * px
                            + plane[j].dcdy * py) * 4;

            mask &= ~sign_bits4(cstep4[j], cx);
        }

        if (mask)
            custom_shade_quads_mask(task, &tri->inputs, px, py, mask, zbuffer, color, mlx);
    }
}

uint32_t max3(uint32_t p1, uint32_t p2, uint32_t p3)
{
	return (fmax(p1, fmax(p2, p3)));
}

uint32_t min3(uint32_t p1, uint32_t p2, uint32_t p3)
{
	return (fmin(p1, fmin(p2, p3)));
}





unsigned build_mask_linear(int32_t c, int32_t dcdx, int32_t dcdy) 
{
    unsigned int mask;
    int32_t c0 = c;
    int32_t c1 = c0 + dcdy;
    int32_t c2 = c1 + dcdy;
    int32_t c3 = c2 + dcdy;

	mask = 0;
    mask |= ((c0 + 0 * dcdx) >> 31) & (1 << 0);
    mask |= ((c0 + 1 * dcdx) >> 31) & (1 << 1);
    mask |= ((c0 + 2 * dcdx) >> 31) & (1 << 2);
    mask |= ((c0 + 3 * dcdx) >> 31) & (1 << 3);
    mask |= ((c1 + 0 * dcdx) >> 31) & (1 << 4);
    mask |= ((c1 + 1 * dcdx) >> 31) & (1 << 5);
    mask |= ((c1 + 2 * dcdx) >> 31) & (1 << 6);
    mask |= ((c1 + 3 * dcdx) >> 31) & (1 << 7);
    mask |= ((c2 + 0 * dcdx) >> 31) & (1 << 8);
    mask |= ((c2 + 1 * dcdx) >> 31) & (1 << 9);
    mask |= ((c2 + 2 * dcdx) >> 31) & (1 << 10);
    mask |= ((c2 + 3 * dcdx) >> 31) & (1 << 11);
    mask |= ((c3 + 0 * dcdx) >> 31) & (1 << 12);
    mask |= ((c3 + 1 * dcdx) >> 31) & (1 << 13);
    mask |= ((c3 + 2 * dcdx) >> 31) & (1 << 14);
    mask |= ((c3 + 3 * dcdx) >> 31) & (1 << 15);

    return mask;
}

void do_mask(int mask, int by, int bx, t_mlx *mlx, t_tri triangle, int zbuffer[HEIGHT][WIDTH], int color)
{
	int endy = by  + 4;
	int endx = bx  + 4;
	for (int y = by; y < endy; y++)
	{
		for (int x = bx; x < endx; x++)
		{
			if (mask & 1)
			{
				if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT && triangle.z[0]< zbuffer[y][x]) {
					zbuffer[y][x] = triangle.x[0];
					mlx_pixel_put(mlx->connection, mlx->window, x, y, 0xFFFFFFFF);
				}
			}
			mask >>= 1;
		}
	}
	(void)color;
}









void rast_tri(t_tri *position, t_mlx *mlx, unsigned int color, int zbuffer[HEIGHT][WIDTH]) {
    struct lp_rasterizer_task task;
    struct lp_rast_triangle tri;
    struct lp_rast_plane planes[NR_PLANES];
    union lp_rast_cmd_arg arg;

    // Initialize structures
    memset(&task, 0, sizeof(task));
    memset(&tri, 0, sizeof(tri));
    memset(&planes, 0, sizeof(planes));
    memset(&arg, 0, sizeof(arg));

    task.width = WIDTH;
    task.height = HEIGHT;

    struct u_rect bbox;
    bbox.x0 = min3(position->x[0], position->x[1], position->x[2]) >> FIXED_ORDER;
    bbox.x1 = (max3(position->x[0], position->x[1], position->x[2]) - 1) >> FIXED_ORDER;
    bbox.y0 = min3(position->y[0], position->y[1], position->y[2]) >> FIXED_ORDER;
    bbox.y1 = (max3(position->y[0], position->y[1], position->y[2]) - 1) >> FIXED_ORDER;

    bbox.x0 = fmax(bbox.x0, 0);
    bbox.y0 = fmax(bbox.y0, 0);
    bbox.x1 = fmin(bbox.x1, WIDTH);
    bbox.y1 = fmin(bbox.y1, HEIGHT);

    // Debugging bbox values
    printf("min_x = %d max_x = %d  min_y = %d max_y %d\n", bbox.x0, bbox.x1, bbox.y0, bbox.y1);

    // Define position vertices
    tri.inputs.stride = sizeof(struct lp_rast_plane) * NR_PLANES;
    arg.position.tri = &tri;

    planes[0].dcdy = position->dx01;
    planes[1].dcdy = position->x[1] - position->x[2];
    planes[2].dcdy = position->dx20;
    planes[0].dcdx = position->dy01;
    planes[1].dcdx = position->y[1] - position->y[2];
    planes[2].dcdx = position->dy20;

    // Debugging vertex and edge values
	printf("------- rast function -----\n");
    printf("Vertex 1: (%d, %d)\n", position->x[0], position->y[0]);
    printf("Vertex 2: (%d, %d)\n", position->x[1], position->y[1]);
    printf("Vertex 3: (%d, %d)\n", position->x[2], position->y[2]);
    printf("dx01: %d, dy01: %d\n", position->dx01, position->dy01);
    printf("dx20: %d, dy20: %d\n", position->dx20, position->dy20);

	 for (int by = bbox.y0; by <= bbox.y1; by += 4) {
        for (int bx = bbox.x0; bx <= bbox.x1; bx += 4) {
            // Compute edge function values at the top-left corner of the block
            int w0 = planes[0].c + planes[0].dcdx * bx + planes[0].dcdy * by;
            int w1 = planes[1].c + planes[1].dcdx * bx + planes[1].dcdy * by;
            int w2 = planes[2].c + planes[2].dcdx * bx + planes[2].dcdy * by;

            // Build masks
            unsigned int mask0 = build_mask_linear(w0, planes[0].dcdx, planes[0].dcdy);
            unsigned int mask1 = build_mask_linear(w1, planes[1].dcdx, planes[1].dcdy);
            unsigned int mask2 = build_mask_linear(w2, planes[2].dcdx, planes[2].dcdy);

            // Combine masks to find pixels inside the triangle
            unsigned int mask = ~(mask0 | mask1 | mask2);

            if (mask) {
                do_mask(mask, by, bx, mlx, *position, zbuffer, color);
            }
        }
    }
}
